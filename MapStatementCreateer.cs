using BveTypes.ClassWrappers;
using BveTypes.ClassWrappers.Extensions;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Resources;
using System.Text;
using System.Threading.Tasks;

namespace BveEx.Toukaitetudou.ExtendedTrainSchedulerWithOudia
{
    internal class MapStatementCreateer
    {
        List<WrappedList<MapStatementClause>> _statements;
        public MapStatementCreateer() { 
            _statements=new List<WrappedList<MapStatementClause>>();
        }
        public MapStatementCreateer Add(WrappedList<MapStatementClause> statements)
        {
            _statements.Add(statements);
            return this;
        }
        public void Create(string filename)
        {
            if (_statements.Count==0) return;
            if (!Directory.Exists(Path.GetDirectoryName(filename)))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(filename));
            }
            using (StreamWriter writer = new StreamWriter(filename))
            {
                writer.WriteLine("BveTs Map 2.02");
                writer.WriteLine($"//------------------------------------------------------------------------------");
                writer.WriteLine($"// <auto-generated>");
                writer.WriteLine($"//     このコードはツールによって生成されました。");
                writer.WriteLine($"//     {typeof(ExtendedTrainSchedulerWithOudia.MapStatementCreateer).Assembly.GetName().Name} Ver. {typeof(ExtendedTrainSchedulerWithOudia.MapStatementCreateer).Assembly.GetName().Version}");
                writer.WriteLine($"//");
                writer.WriteLine($"//     このファイルへの変更は、以下の状況下で不正な動作の原因になったり、");
                writer.WriteLine($"//     コードが再生成されるときに損失したりします。");
                writer.WriteLine($"// </auto-generated>");
                writer.WriteLine($"//------------------------------------------------------------------------------");
                writer.WriteLine("ex_argdistance;");
                for (int i = 0; i< _statements.Count; i++)
                {
                    writer.WriteLine(getClauses(_statements[i]));
                }
            }
        }
        private string getClauses(WrappedList<MapStatementClause> mapStatementClauses)
        {
            string rt=string.Empty;
            for (int i=0;i< mapStatementClauses.Count;++i)
            {
                MapStatementClause clause = mapStatementClauses[i];
                rt += getClause(clause);
                if(i<mapStatementClauses.Count-1)
                {
                    rt+=".";
                }
            }
            rt+=";";
            return rt;
        }
        private string getClause(MapStatementClause mapStatementClause)
        {
            string rt = mapStatementClause.Name;
            foreach(object obj in mapStatementClause.Keys) 
            {
                rt+=$"[{ObjectToString(obj)}]";
            }
            if (mapStatementClause.Args.Count > 0)
            {
                rt+="(";
                for (int i=0;i< mapStatementClause.Args.Count;++i)
                {
                    object obj = mapStatementClause.Args[i];
                    rt+=$"{ObjectToString(obj)}";
                    if(i<mapStatementClause.Args.Count-1)
                    {
                        rt+=", ";
                    }
                }
                rt+=")";
            }
            
            return rt;
        }
        private string ObjectToString(object obj)
        {
            if(obj is null)
            {
                return string.Empty;
            }
            if(obj is string)
            {
                return $"'{obj.ToString()}'";
            }
            return obj.ToString();
        }
    }
}
